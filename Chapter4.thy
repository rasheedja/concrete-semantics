theory Chapter4
  imports "~~/src/HOL/IMP/ASM"
begin

(*
Exercise 4.1. Start from the data type of binary trees defined earlier:
datatype 'a tree = Tip | Node "'a tree" 'a "'a tree"
0Define a function set :: 'a tree \<Rightarrow> 'a set that returns the elements in a tree
and a function ord :: int tree \<Rightarrow> bool that tests if an int tree is ordered.
Define a function ins that inserts an element into an ordered int tree
while maintaining the order of the tree. If the element is already in the tree,
the same tree should be returned. Prove correctness of ins: set (ins x t) =
{x} \<union> set t and ord t \<Longrightarrow> ord (ins i t).
*)

datatype 'a tree = Tip | Node "'a tree" 'a "'a tree"

fun set :: "'a tree \<Rightarrow> 'a set" where
"set (Tip) = {}" |
"set (Node l a r) = (set l) \<union> {a} \<union> (set r)"

fun ord :: "int tree \<Rightarrow> bool" where
"ord (Tip) = True" |
"ord (Node l a r) = (ord l \<and> (\<forall>x\<in>(set l). x < a) \<and> ord r \<and> (\<forall>x\<in>(set r). x > a))"

fun ins :: "int \<Rightarrow> int tree \<Rightarrow> int tree" where
"ins x Tip = Node Tip x Tip" |
"ins x (Node l a r) = (if x = a then (Node l a r)
                       else if x < a then (Node (ins x l) a r)
                       else (Node l a (ins x r)))"


lemma set_ins: "set (ins x t) = {x} \<union> set t"
  apply(induction t arbitrary: x)
   apply(auto)
  done

lemma ord_ins: "ord t \<Longrightarrow> ord (ins x t)"
  apply(induction t arbitrary: x)
   apply(auto simp add: set_ins)
  done

(*
Exercise 4.2. Formalize the following definition of palindromes
 The empty list and a singleton list are palindromes.
 If xs is a palindrome, so is a # xs @ [a].
as an inductive predicate palindrome :: 'a list \<Rightarrow> bool and prove that rev xs
= xs if xs is a palindrome. 
*)

inductive palindrome :: "'a list \<Rightarrow> bool" where
paE: "palindrome []" |
paS: "palindrome [x]" |
paX: "palindrome xs \<Longrightarrow> palindrome (a # xs @ [a])"

lemma "palindrome xs \<Longrightarrow> rev xs = xs"
  apply(induction rule: palindrome.induct)
    apply(auto)
  done

(*
Exercise 4.3. We could also have defined star as follows:
inductive star' :: "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool" for r where
refl' : "star' r x x" |
step' : "star' r x y =\<Rightarrow> r y z =\<Rightarrow> star' r x z"
The single r step is performed after rather than before the star steps. Prove
star' r x y =\<Rightarrow> star r x y and star r x y =\<Rightarrow> star' r x y. You may need
lemmas. Note that rule induction fails if the assumption about the inductive
predicate is not the first assumption.
*)

inductive star :: "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool" for r where
refl : "star r x x" |
step : "r x y \<Longrightarrow> star r y z \<Longrightarrow> star r x z"

inductive star' :: "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool" for r where
refl' : "star' r x x" |
step' : "star' r x y \<Longrightarrow> r y z \<Longrightarrow> star' r x z"


lemma star_trans: "star r x y \<Longrightarrow> star r y z \<Longrightarrow> star r x z"
  apply(induction rule: star.induct)
   apply(assumption)
  apply(metis step)
  done

lemma star'_trans : "star' r y z \<Longrightarrow> star' r x y \<Longrightarrow> star' r x z"
  apply(induction rule: star'.induct)
   apply(assumption)
  apply(metis step')
  done

lemma star'_implies_star: "star' r x y \<Longrightarrow> star r x y"
  apply(induction rule: star'.induct)
   apply(metis refl)
  apply (meson refl step star_trans)
  done

lemma star_implies_star': "star r x y \<Longrightarrow> star' r x y"
  apply(induction rule: star.induct)
   apply(metis refl')
  apply(meson refl' step' star'_trans)
  done

(*
Exercise 4.4. Analogous to star, give an inductive definition of the n-fold
iteration of a relation r : iter r n x y should hold if there are x0, . . . , xn such
that x = x0 , xn = y and r xi xi+1 for all i < n. Correct and prove the
following claim: star r x y \<Longrightarrow> iter r n x y.
*)

inductive iter :: "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool" for r where
it0 : "iter r 0 x x" |
itSS : "r x y \<Longrightarrow> iter r n y z \<Longrightarrow> iter r (Suc n) x z"

lemma "star r x y \<Longrightarrow> \<exists>n. iter r n x y"
  apply(induction rule: star.induct)
   apply(metis it0)
  apply(metis itSS)
  done

(*
Exercise 4.5. A context-free grammar can be seen as an inductive definition
where each nonterminal A is an inductively defined predicate on lists of ter-
minal symbols: A(w) means that w is in the language generated by A. For
example, the production S \<rightarrow> aSb can be viewed as the implication S w =\<Rightarrow>
S (a # w @ [b]) where a and b are terminal symbols, i.e., elements of some
alphabet. The alphabet can be defined like this: datatype alpha = a | b | . . .
Define the two grammars (where \<epsilon> is the empty word)
S \<rightarrow> \<epsilon> | aSb | SS
T \<rightarrow> \<epsilon> | TaTb
as two inductive predicates. If you think of a and b as ‚Äú(‚Äù and ‚Äú)‚Äù, the
grammar defines strings of balanced parentheses. Prove T w =\<Rightarrow> S w and
S w =\<Rightarrow> T w separately and conclude S w = T w.
*)

datatype alpha = ay | be | ce | de | ee | ef | ge 

inductive S :: "alpha list \<Rightarrow> bool" where
S0 : "S []" |
Sw : "S w \<Longrightarrow> S (a # w @ [b])" |
Sc : "S w1 \<Longrightarrow> S w2 \<Longrightarrow> S (w1 @ w2)"

inductive T :: "alpha list \<Rightarrow> bool" where
T0 : "T []" |
Tw : "T w \<Longrightarrow> T x \<Longrightarrow> T (w @ [a] @ x @ [b])"

lemma T_comm: "T w \<Longrightarrow> T x \<Longrightarrow> T (x @ w)"
  apply(induction rule: T.induct)
   apply(simp)
  apply(metis Tw append_assoc)
  done

lemma T_implies_S: "T w \<Longrightarrow> S w"
  apply(induction rule: T.induct)
   apply(metis S0)
  apply(simp add: Sw Sc)
  done

lemma S_implies_T: "S w \<Longrightarrow> T w"
  apply(induction rule: S.induct)
    apply(metis T0)
   apply (metis Cons_eq_appendI T.simps self_append_conv2)
  apply(simp add: T_comm)
  done

theorem S_eq_T: "S w = T w"
  apply(auto simp add: T_implies_S S_implies_T)
  done

(*
Exercise 4.6. In Section 3.1 we defined a recursive evaluation function aval
:: aexp \<Rightarrow> state \<Rightarrow> val. Define an inductive evaluation predicate aval_rel
:: aexp \<Rightarrow> state \<Rightarrow> val \<Rightarrow> bool and prove that it agrees with the recursive
function: aval_rel a s v =\<Rightarrow> aval a s = v, aval a s = v =\<Rightarrow> aval_rel a s v
and thus aval_rel a s v \<leftarrow>\<rightarrow> aval a s = v .
*)

inductive avalrel :: "aexp \<Rightarrow> state \<Rightarrow> val \<Rightarrow> bool" where
arN : "avalrel (N a) s a" |
arV : "avalrel (V x) s (s x)" |
arP : "avalrel p1 s v1 \<Longrightarrow> avalrel p2 s v2 \<Longrightarrow> avalrel (Plus p1 p2) s (v1 + v2)"

lemma avalrel_implies_aval: "avalrel a s v \<Longrightarrow> aval a s = v"
  apply(induction rule: avalrel.induct)
    apply(simp_all add: arN arV arP)
  done

lemma aval_implies_avalrel: "aval a s = v \<Longrightarrow> avalrel a s v"
  apply(induction a arbitrary: v)
    apply(auto simp add: arN arV arP)
  done

theorem avalrel_iff_aval: "avalrel a s v \<longleftrightarrow> aval a s = v"
  using aval_implies_avalrel avalrel_implies_aval by blast

(*
Exercise 4.7. Consider the stack machine from Chapter 3 and recall the
concept of stack underflow from Exercise 3.10. Define an inductive predicate
ok :: nat \<Rightarrow> instr list \<Rightarrow> nat \<Rightarrow> bool such that ok n is n' means that with
any initial stack of length n the instructions is can be executed without stack
underflow and that the final stack has length n'. Prove that ok correctly
computes the final stack size
l'
and that instruction sequences generated by comp cannot cause stack under-
flow: ok n (comp a) ? for some suitable value of ?.
*)

end
